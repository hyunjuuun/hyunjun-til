# JVM은 클래스를 어떻게 로딩하고 실행할까?

## 배경 (정리 목적)
[2026-02-02. JVM은 왜 플랫폼 독립적일까.md](https://github.com/hyunjuuun/hyunjun-til/blob/main/til/2026/2026-02-02.%20JVM%EC%9D%80%20%EC%99%9C%20%ED%94%8C%EB%9E%AB%ED%8F%BC%20%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%BC%EA%B9%8C.md) 에서  
JVM의 전체 실행 구조를 정리했다면,  
이번에는 그 구조 안에서 클래스 로딩과 실행이 실제로 어떻게 이어지는지를  
실행 서브 시스템 관점에서 정리해보려 한다.

백엔드 개발을 하다 보면 `ClassNotFoundException`, GC 튜닝, JIT 성능 이슈처럼  
“실행 중에 발생하는 문제”를 마주치게 되는데,  
이런 문제들은 대부분 **클래스 로딩 방식과 실행 서브 시스템**과 연관된 이슈이다.

이번 TIL에서는 JVM 실행 서브 시스템을 중심으로  
클래스 로딩 과정, 힙 영역, 그리고 인터프리터와 JIT의 역할을 한 흐름으로 정리한다.

---

## 1. JVM은 클래스를 언제 로딩하고, 왜 실행 중에 결정하는가

JVM은 애플리케이션 시작 시 모든 클래스를 한 번에 로딩하지 않는다.  
클래스는 **필요해지는 시점**에 로딩된다.

이 필요 시점은 다음과 같다.
- 클래스의 인스턴스를 처음 생성할 때
- static 필드나 메서드에 처음 접근할 때
- 메서드 호출 과정에서 참조될 때

이 방식은 메모리 사용을 줄이고,  
실제로 사용되지 않는 클래스에 대한 불필요한 로딩을 방지한다는 점에서 중요하다.

즉, 클래스 로딩은 “사전 준비”가 아니라  
**실행 흐름에 따라 점진적으로 발생하는 과정**이다.

---

## 2. Class Loader의 역할: 로딩, 링킹, 초기화

클래스 로딩은 단일 단계가 아니라 **세 단계로 나뉜다**.

### 로딩 (Loading)
- `.class` 파일을 찾아 JVM 메모리로 읽어들이는 단계
- 클래스의 바이트코드를 확보하고, 클래스 메타데이터 생성을 준비한다

이 단계의 결과는 이후 Method Area(Metaspace)에 저장된다.

---

### 링킹 (Linking)
로딩된 클래스를 **실행 가능한 상태로 정비하는 단계**로, 세부적으로 나뉜다.

- **검증(Verification)**  
  바이트코드가 JVM 규칙을 위반하지 않았는지 검사한다.  
  이는 JVM 안정성과 보안의 핵심이다.

- **준비(Preparation)**  
  static 변수에 메모리를 할당하고, 기본값(0, null 등)을 설정한다.  
  아직 개발자가 명시한 값은 적용되지 않는다.

- **해결(Resolution)**  
  심볼릭 레퍼런스를 실제 메모리 참조로 연결한다.  
  이 과정은 필요 시점까지 지연될 수 있다.

링킹 단계는 “보이지 않지만 중요한 안정화 과정”이라는 점에서 의미가 있다.

---

### 초기화 (Initialization)
- static 초기화 블록과 static 필드의 명시적 초기값이 적용되는 단계
- 개발자가 작성한 코드가 **처음으로 실행되는 시점**

이 단계가 끝나야 비로소 클래스는 “사용 가능한 상태”가 된다.

---

## 3. JVM 힙 영역은 어떤 역할을 하는가

힙(Heap)은 **객체 인스턴스가 생성되는 메모리 영역**이다.

- 모든 스레드가 공유한다
- Garbage Collector의 관리 대상이다
- 대부분의 성능 이슈와 메모리 문제는 힙과 직접적으로 연관된다

중요한 점은,  
클래스 자체(메타데이터)는 힙이 아니라 Method Area에 저장되고,  
**힙은 오직 객체 인스턴스만을 위한 공간**이라는 것이다.

따라서 힙에 대한 이해는
- GC 동작
- 메모리 누수
- 객체 생명주기

를 이해하기 위한 출발점이 된다.

---

## 4. 인터프리터와 JIT는 언제 개입하는가

클래스 로딩과 초기화가 끝났다고 해서,  
곧바로 JIT 컴파일이 수행되는 것은 아니다.

### 인터프리터
- JVM 실행의 시작점
- 바이트코드를 한 줄씩 해석하며 실행
- 빠른 시작이 가능하지만 반복 실행에는 비효율적

모든 코드는 **처음에는 인터프리터로 실행**된다.

---

### JIT 컴파일러
- 실행 중인 코드를 관찰(profiling)하다가
- 자주 실행되는 코드(Hot Spot)를 발견하면 개입한다
- 해당 바이트코드를 CPU에 최적화된 기계어로 컴파일한다

이후에는 인터프리터 대신 **기계어가 직접 실행**된다.

즉, JIT는
- 클래스 로딩 이후
- 실행 중간(Runtime)에
- 선택적으로 개입하는 최적화 장치다.

---

## 정리
- JVM은 클래스를 필요 시점에 로딩하고, 로딩·링킹·초기화 단계를 거쳐 실행을 준비한다.
- 힙은 객체 인스턴스를 위한 공간이며, GC와 성능 이슈의 중심이다.
- JVM은 인터프리터로 실행을 시작하고, JIT는 실행 중간에 개입해 성능을 최적화한다.

### 더 살펴볼 내용
- GC 알고리즘과 힙 세부 구조
- Spring Boot에서 Class Loader가 확장되는 방식
