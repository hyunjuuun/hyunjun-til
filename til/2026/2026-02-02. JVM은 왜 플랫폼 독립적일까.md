# JVM은 왜 플랫폼 독립적일까?

## 1. JVM이 플랫폼 독립적일 수 있는 이유

JVM(Java Virtual Machine)이 플랫폼 독립적인 이유는  
애플리케이션 코드가 운영체제나 CPU에서 직접 실행되지 않기 때문이다.

Java나 Kotlin 코드는 컴파일 시점에 **특정 플랫폼용 기계어가 아니라 JVM 바이트코드**로 변환된다.  
이 바이트코드는 운영체제나 하드웨어에 종속되지 않으며,  
각 플랫폼에 맞게 구현된 JVM이 이를 해석하거나 컴파일하여 실행한다.

결국 플랫폼 차이를 흡수하는 주체는 애플리케이션 코드가 아니라 JVM이며,  
이 구조 덕분에 동일한 바이트코드를 여러 환경에서 그대로 실행할 수 있다.  
이 점이 JVM 기반 언어들이 플랫폼 독립성을 갖는 핵심이다.

---

## 2. Kotlin 코드는 JVM에서 어떻게 실행되는가

Kotlin은 JVM 위에서 동작하는 언어로, 실행 시점에는 Kotlin 코드가 아니라  
**Kotlin 컴파일러가 생성한 JVM 바이트코드가 실행**된다.

컴파일 단계에서 Kotlin 컴파일러(kotlinc)는 `.kt` 파일을 `.class` 파일로 변환하며,  
이 결과물은 JVM 관점에서 Java 바이트코드와 동일하게 취급된다.  
이 시점 이후 JVM은 코드가 Kotlin으로 작성되었는지 여부에 관심을 두지 않는다.

실행 단계에서는 역할이 명확히 분리된다.

- Kotlin 컴파일러는 컴파일 시점까지만 관여한다.
- JVM은 바이트코드를 로딩하고, 실행 방식(인터프리터 또는 JIT)을 결정하며,
  메모리 관리와 GC를 수행한다.
- 운영체제는 JVM 프로세스를 실행하고 시스템 자원을 제공한다.

즉, Kotlin 컴파일러는 Kotlin 코드를 JVM이 이해할 수 있는 형태로 변환하는 역할까지만 담당하고,  
그 이후 실제 실행 과정에서는 JVM이 바이트코드를 읽고 메서드를 호출하며  
객체 생성, 메모리 관리, GC까지 전반적인 실행 책임을 진다.  
운영체제는 JVM이라는 프로그램을 실행하고 시스템 자원을 제공할 뿐이며,  
이로 인해 프로그램 실행의 중심적인 주체는 JVM이 된다.

---

## 3. JVM 메모리 구조는 어떻게 구성되어 있는가

JVM은 프로그램 실행을 위해 여러 메모리 영역을 사용하며,  
각 영역은 서로 다른 책임을 가진다.

### Method Area (Metaspace)
- 클래스 메타데이터가 저장되는 영역
- 클래스 구조, 메서드 정보, 상수 풀, static 변수 등을 포함
- 모든 스레드가 공유

Kotlin의 `object`, `companion object`, `const val` 등은  
이 영역과 직접적인 연관이 있다.

### Heap 영역
- 객체 인스턴스가 생성되는 공간
- 모든 스레드가 공유
- Garbage Collector의 관리 대상

일반적으로 언급되는 메모리 누수나 GC 이슈는  
대부분 Heap 영역과 관련된다.

### Stack 영역
- 메서드 호출 시 생성되는 Stack Frame을 관리
- 지역 변수, 매개변수, 반환 주소 등을 저장
- 스레드마다 독립적으로 존재

재귀 호출이 과도할 경우 발생하는 `StackOverflowError`는  
이 영역의 한계로 인해 발생한다.

### 기타 영역
- PC Register: 현재 실행 중인 JVM 명령어 위치를 저장
  - 각 스레드가 지금 ‘어디까지 실행했는지’를 JVM이 기억하기 위한 메모리 공간
- Native Method Stack: JNI(Java Native Interface) 등을 통해 네이티브 코드를 실행할 때 사용

---

## 정리
- JVM은 바이트코드를 실행함으로써 운영체제와 하드웨어 차이를 추상화한다.
- Kotlin 코드는 JVM 위에서 실행되며, 실행 책임은 JVM에 있다.
- JVM 메모리 구조에 대한 이해는 성능 이슈와 내부 동작을 파악하는 기초가 된다.

### 더 살펴볼 내용
- JVM 실행 서브 시스템 (인터프리터, JIT 컴파일러)
- Heap 구조와 Garbage Collection 동작 방식