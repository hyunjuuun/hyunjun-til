# 컴파일, 빌드, 배포의 차이점과 역할 정리

## 배경 (정리 목적)
백엔드 개발을 하다 보면 “컴파일 에러”, “빌드 실패”, “배포 장애”라는 표현을 자주 마주한다.  
하지만 이 용어들을 명확히 구분하지 않으면, 문제가 발생했을 때 **어디를 먼저 점검해야 하는지** 판단이 흐려진다.

언어와 플랫폼이 달라져도 컴파일·빌드·배포라는 단계 자체는 반복해서 등장한다.  
이 문서는 컴파일·빌드·배포를 구분해 정리하고 명확히 이해하기 위한 기록이다.

## 핵심 내용

### 1. 컴파일은 언어 규칙을 검증하고 실행 단위로 변환하는 단계
컴파일은 사람이 작성한 소스 코드가 **언어 스펙을 만족하는지**를 검사하고,  
해당 언어의 실행 환경이 이해할 수 있는 형태로 변환하는 과정이다.

이 변환 결과는 언어와 플랫폼에 따라 다르다.
- JVM 계열: 소스 코드 → 바이트코드(`.class`)
- C / C++: 소스 코드 → 네이티브 바이너리
- Go: 소스 코드 → 단일 실행 바이너리
- 인터프리터 언어도 내부적으로는 파싱·검증 단계를 거친다

공통점은 다음과 같다.
- 문법 오류, 타입 불일치, 접근 제어 위반 등은 이 단계에서 발견된다
- 결과물은 **아직 서비스로 배포할 수 있는 상태는 아니다**

컴파일의 핵심 질문은  
**“이 코드는 해당 언어 규칙상 올바른가?”** 이다.

### 2. 빌드는 실행 가능한 산출물을 만드는 과정
빌드는 컴파일 결과물을 중심으로,  
애플리케이션을 **실제로 실행하거나 배포할 수 있는 단위**로 조립하는 단계다.

언어와 생태계에 따라 빌드의 형태는 다르지만, 포함하는 책임은 유사하다.
- 컴파일 수행 또는 포함
- 외부 의존성 해석 및 결합
- 리소스 파일 포함
- 실행 또는 배포 가능한 산출물 생성
- 테스트 실행 (빌드 과정에 포함되는 경우가 많음)

#### 빌드 산출물의 예
- JVM: JAR, WAR
- Go: 단일 바이너리
- Node.js: 의존성이 포함된 배포 디렉터리
- 컨테이너 환경: Docker 이미지

이 단계의 관점은  
**“이 애플리케이션을 실행 가능한 형태로 만들 수 있는가?”** 이다.

빌드 실패는 코드 문법 문제보다는  
의존성 충돌, 설정 오류, 빌드 스크립트 문제에서 발생하는 경우가 많다.

### 3. 배포는 빌드 산출물을 실행 환경에 반영하는 단계
배포는 빌드된 결과물을 **어디에서, 어떤 방식으로 실행할 것인지**를 다룬다.  
이 단계부터 애플리케이션은 코드가 아니라 **운영 대상**이 된다.

배포 단계에서 다루는 대표적인 책임은 다음과 같다.

#### 빌드 산출물 전달
- 실행 파일, 패키지, 이미지 등을 서버나 레지스트리에 업로드한다
- 이 시점부터 동일한 산출물이 여러 환경에서 재사용될 수 있다

#### 실행 환경 설정 적용
- 환경 변수, 시크릿, 외부 시스템 주소 등을 주입한다
- 동일한 빌드 산출물이라도 환경 설정에 따라 동작은 달라질 수 있다

#### 애플리케이션 프로세스 기동 또는 교체
- 신규 프로세스를 기동하거나 기존 프로세스를 교체한다
- 헬스 체크, 기동 순서, 종료 방식이 중요해진다

#### 트래픽 전환
- 점진적 전환(롤링 업데이트)
- 사용자 영향 최소화를 위한 무중단 배포 전략

배포 단계의 문제는 코드와 빌드가 정상이어도 발생할 수 있다.  
네트워크, 인프라 설정, 권한, 환경 차이가 주요 원인이다.

### 4. 단계를 구분하면 문제의 성격이 보인다
- 컴파일 에러 → 코드 자체의 문제
- 빌드 실패 → 의존성, 설정, 빌드 정의 문제
- 배포 실패 → 인프라, 환경, 운영 절차 문제

## 정리
- 컴파일은 언어 차원의 검증, 빌드는 실행 단위 생성, 배포는 실행 환경 전달이다.
- 세 단계를 분리해서 이해하면 문제 원인과 책임 범위를 명확히 나눌 수 있다.